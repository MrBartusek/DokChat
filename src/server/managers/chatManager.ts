import db from '../db';
import sql from 'sql-template-strings';
import { UserJWTData } from '../../types/jwt';
import { Chat, ChatParticipant } from '../../types/common';
import Utils from '../utils';
import { Request } from 'express';
import { Handshake } from 'socket.io/dist/socket';

export default class ChatManager {
	public static async hasChatAccess(auth: UserJWTData, chatId: string) {
		const permissionsQuery = await db.query(sql`
            SELECT EXISTS(SELECT 1 FROM participants WHERE user_id = $1 AND conversation_id=$2)
        `, [auth.id, chatId]);
		return permissionsQuery.rows[0].exists;
	}

	/**
	 * List participant user ids in chat without any joins
	 */
	public static async listParticipantsUserIds(conversationId: string): Promise<string[]> {
		const query = await db.query(sql`
			SELECT
				user_id as "userId"
			FROM
				participants
			WHERE conversation_id = $1;
		`, [ conversationId ]);
		return query.rows.map(r => r.userId);
	}

	public static async chatInfo(req: Request | Handshake, conversationId: string): Promise<Chat> {
		const chats = await db.query(sql`
			SELECT
				name, avatar
			FROM
				conversations
			WHERE id = $1
			LIMIT 1;
		`, [ conversationId ]);
		if(chats.rowCount == 0) throw new Error('Chat with provided id was not found');
		const participants = await ChatManager.listParticipants(req, conversationId);
		const [avatar, name] = await ChatManager.generateAvatarAndName(req, conversationId, participants, chats.rows[0].name, chats.rows[0].avatar);
		return {
			id: conversationId,
			avatar: avatar,
			name: name
		};
	}

	public static async listParticipants(req: Request | Handshake, conversationId: string): Promise<ChatParticipant[]> {
		const query = await db.query(sql`
			SELECT
				participants.id,
				user_id as "userId",
				username, tag
			FROM
				participants
			JOIN users ON users.id = user_id
			WHERE conversation_id = $1;
		`, [ conversationId ]);
		const result: ChatParticipant[] = [];
		for(const part of query.rows) {
			result.push({
				id: part.id,
				userId: part.userId,
				username: part.username,
				tag: part.tag,
				avatar: Utils.avatarUrl(req, part.userId)
			});
		}
		return result;
	}

	/**
	 * Get avatar and name of conversation and generate default ones
	 * if they are missing
	 */
	public static async generateAvatarAndName(
		req: Request | Handshake,
		chatId: string,
		participants: ChatParticipant[],
		rawName: string,
		rawAvatar: string
	): Promise<[string, string]> {
		const isSelfChat = participants.length == 1;
		const isDirectMessage = participants.length == 2;
		const isGroup = participants.length > 2;
		if(isSelfChat) {
			const part = participants[0];
			return [
				rawAvatar || Utils.avatarUrl(req, part.userId),
				rawName || `${part.username}#${part.tag}`
			];
		}
		else if(isDirectMessage) {
			const user = participants.find(u => u.userId != req.auth.id);
			return [
				rawAvatar || Utils.avatarUrl(req, user.userId),
				rawName || `${user.username}#${user.tag}`
			];
		}
		else if(isGroup) {
			const autoGeneratedName = participants.map(u => u.username).join(', ').substring(0, 32);
			return [
				rawAvatar || Utils.avatarUrl(req, chatId),
				rawName|| autoGeneratedName
			];
		}
		return ['', ''];
	}
}
