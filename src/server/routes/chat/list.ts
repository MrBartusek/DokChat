import * as express from 'express';
import { ChatListResponse, MessageListResponse, UserLoginResponse } from '../../../types/endpoints';
import { ApiResponse } from '../../apiResponse';
import db from '../../db';
import sql from 'sql-template-strings';
import allowedMethods from '../../middlewares/allowedMethods';
import ensureAuthenticated from '../../middlewares/ensureAuthenticated';
import Utils from '../../utils';
import { QueryResult } from 'pg';

const router = express.Router();

router.all('/list', allowedMethods('GET'), ensureAuthenticated(), async (req, res, next) => {
	const page = req.query.page as any as number|| 0;
	if(isNaN(page)) return new ApiResponse(res).badRequest();

	const chatsQuery = await queryChats(req, page);
	const chats = await Promise.all(chatsQuery.rows.map(async (chat) => {
		console.log(chat);
		const participantsQuery = await queryParticipants(chat.conversationId);
		const [avatar, chatName] = generateAvatarAndName(req, chat, participantsQuery);

		return {
			id: chat.conversationId,
			name: chatName,
			avatar: avatar,
			lastMessage: chat.message ? {
				content: chat.message,
				author: chat.messageAuthor
			}: null
		};
	}));
	const result: ChatListResponse = chats;
	new ApiResponse(res).success(result);
});

type ChatsQuery = QueryResult<{
	conversationId: string,
	name: string,
	message: string,
	messageAuthor: string
}>
async function queryChats(req: express.Request, page: number): Promise<ChatsQuery> {
	return db.query(sql`
        SELECT
            participants.conversation_id as "conversationId",
            conversation.name,
            last_message.content as message,
            last_message_author.username as "messageAuthor"
        FROM participants
        -- Join last message
        LEFT JOIN LATERAL (
            SELECT messages.conversation_id, messages.author_id, messages.content FROM messages
            WHERE participants.conversation_id = messages.conversation_id ORDER BY
            messages.created_at DESC LIMIT 1
        ) AS last_message ON true
        -- Join conversation
        LEFT JOIN LATERAL (
            SELECT conversations.id, conversations.name FROM conversations
            WHERE conversations.id = participants.conversation_id
            LIMIT 1
        ) AS conversation ON true
        -- Join last message author
        LEFT JOIN LATERAL (
            SELECT users.id, users.username FROM users
            WHERE users.id = last_message.author_id
            LIMIT 1
        ) AS last_message_author ON true
        WHERE
            participants.user_id = $1
        LIMIT 25 OFFSET $2;
    `, [req.auth.id, page]);
}

type ParticipantsQuery = QueryResult<{
	userId: string,
	username: string,
	tag: string
}>
async function queryParticipants(conversationId: string): Promise<ParticipantsQuery> {
	return db.query(sql`
		SELECT
			user_id as "userId",
			username, tag
		FROM
			participants
		JOIN users ON users.id = user_id
		WHERE conversation_id = $1;
	`, [ conversationId ]);
}

function generateAvatarAndName(req: express.Request, chat: any, participantsQuery: ParticipantsQuery): [string, string] {
	const isSelfChat = participantsQuery.rowCount == 1;
	const isDirectMessage = participantsQuery.rowCount == 2;
	const isGroup = participantsQuery.rowCount > 2;
	if(isSelfChat) {
		const user = participantsQuery.rows[0];
		return [
			Utils.avatarUrl(req, user.userId),
			chat.name || `${user.username}#${user.tag}`
		];
	}
	else if(isDirectMessage) {
		const user = participantsQuery.rows.find(u => u.userId != req.auth.id);
		return [
			Utils.avatarUrl(req, user.userId),
			chat.name || `${user.username}#${user.tag}`
		];
	}
	else if(isGroup) {
		const autoGeneratedName = participantsQuery.rows.map(u => u.username).join(', ').substring(0, 32);
		return [
			Utils.avatarUrl(req, chat.conversationId),
			chat.name || autoGeneratedName
		];
	}
	return ['', ''];
}

export default router;
